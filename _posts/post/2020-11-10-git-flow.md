---
layout: post
title:  "浅谈git协作"
date:   2020-11-19
excerpt: "谈谈自己对于git flow和github flow的理解"
feature: https://static.justice-love.com/image/jpg/bjfj1.jpg
tag:
- git
- git flow
comments: true
---
## 背景

现在团队开发大多都是使用git flow或者github flow来进行团建建协作管理，这里主要谈谈自己队医git flow和github flow的理解以及他们的好处和限制以及个人觉得较优的流程是个什么样子。

## git flow

### 简介

典型的git flow拥有三个主分支develop，test，master，一般对应着开发流程中的三个环境，开发，测试，正式。而像flow这个单词所所描述的那样，代码是在不同的节点流向另一个分支。

### 好的点

现在大多数的开发团队都是首选git flow作业团队协作模型，其主要原因也是git flow的三个分支能够很好的对应到业务开发流程中的三个环境开发，测试，正式，而遵循git flow的规范，即代码只能从一个方向往下流，即develop -> test -> master，这样是为了保证git commit 数据流的规整，当然如果需要hotfix，git flow的规范也有包含，但是注意，同样需要准许代码只能往一个方向流动的规则，如果的确需要倒流，可以使用cherry-pick。

### 欠缺的点

git flow规范中对应的三个分支，是固定分支，而需求是不固定的，这就使得分支成为了被竞争的有限资源，比如同时存在两个进行中的需求，一个是大版本的需求，开发测试时间跨度都很大，一个是短期的优化需求，这样在使用test分支这个有限资源是，就存在竞争情况，这样就导致了无法直接使用test分支合并到master分支发布，而如何合并也会由于git的特性而导致新的问题。
如果直接将feature分支合并到master，则不会引入一些问题，但这也导致了可能会将feature分支上未发布的代码带入到master。如果使用cherry-pick合并（是否rebase -i依据个人习惯），则会导致commit发生变更，这样就会导致如果后续再将test合并到master，由于test和master都存在相同的代码改动，但不属于同一个commit，会被git识别成冲突。
所以，如果想很好的使用git flow，需要有一个固定的版本规划。

## github flow

### 简介

其实github flow是相对于git flow来的，他只拥有一个主分支，并没有代码流动的概念。github flow的主要场景是对主分支master分支进行保护，所有对master分支的合并必须经过完整的PR流程

### 好的点

关键的好处就是简单，因为只有一个主分支，只需要对其进行保护和PR操作，没有git flow这么复杂的代码流动，hotfix处理，也就不会存在太过于复杂的git commit 数据流。

### 欠缺的点

欠缺的点也很明显，就是不好和日常开发流程很好的匹配，所以github flow一般是对开源项目的维护中使用，由项目的PMC来保证代码的质量。

## 是否可以混用

这两种协作方式都是单纯的技术点，没有明确的规定哪里该怎么使用，只有选择自己合适的方式。一般情况下，更多的是在git flow里混合github flow的PR来使用。
个人是不建议这种使用方式的，因为PR的主旨很明显，是用来对主分支进行保护的，尤其是PR的squash功能在这点上特别明显，squash是用来合并提交merge，这里主要是保护主分支不使其有过多过散的git commit 数据流。
而如果在git flow中使用了这种方式，就会导致主分支和另外两个分支，像test分支，拥有相同的代码改动，却属于两个不同的commit，这样会导致下次代码流动，会有过多的冲突，长久以往，几乎是无法完成一次代码流动。
而git flow也和github flow大的不同是，git flow主要靠测试来保证代码的可靠性，而github flow要靠review来保证其主分支的可靠性。

## 个人觉得好的协作方式

比较推崇github flow的单一主分支的方式，这样对于代码的维护会简单很多，而具体开发过程中，git flow的三个分支能够很好的对应开发流程中的三个环境，但是其是固定分支，会引入竞争的情况，可以将这三个分支抽象为动态分支，即

1. 环境是固定的，为开发，测试，正式
2. 分支是动态的，为dev_{suffix}, test_{suffix}, master_{suffix}
3. 不同环境的动态分支是可以随时创建(因为主分支只有master一个分支，所有的动态分支都是基于master创建，所以feature可以随意的合并到基于master创建的动态分支)
    * 从master分支拉出对应的动态分支，如test_{suffix}
    * 对应的feature分支合并到test_{suffix}即为当前的
4. 如果一个分支临时需要进入测试，则只需将feature合并到test_{suffix}
5. 如果版本规划固定，可以参考git flow的代码流动，直接将下游的动态分支上升到上有，如test_{suffix}上升为master_{suffix}，这样也保证了测试的延续性
6. 如果存在单独的需求需要提前进入发布流程，则可以单独创建master动态分支
    * 从master分支拉出对应的动态分支master_{suffix}
    * 将feature合并到master_{suffix}
    * 发布完成后，将master_{suffix}合并到master即可
7. 因为只有一个主分支，所以hotfix也不存在git flow那样的复杂操作，按正常流程执行即可

上述方案有一定的复杂度，如需要实现，对CI系统有一定的要求。