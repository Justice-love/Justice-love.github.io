---
layout: post
title:  "设计模式(一)"
date:   2017-01-28
excerpt: "设计原则：抽象工厂模式，模版方法模式，建造者模式"
tag:
- 设计原则
comments: true
---
> 打算写几篇关于设计模式的连载，今天是开篇，关于抽象工厂模式，模版方法模式和建造者模式。
每个设计模式的详解都包括的我的理解以及我的分析推导过程。

# 抽象工厂模式
理解：该设计模式是工厂模式的扩展，工厂类接口定义一组产品的生产规范，比如轿车门。工厂接口的实现类则具体来完成这一组产品中的一类的生产流程，比如左轿车门。

分析/推导：

* 普通的工厂模式使用比较频繁，也有很多变种，但是我们大多数使用较多的是简单工厂模式，即工厂类无继承，通过静态方法来获取生产产品对象。
* 抽象生产模式在普通工厂模式上再抽象出了一个工厂接口，工厂接口用来定义一组产品的"设计规范"并产出产品。
* 工厂接口的实现类则用来实际生产工厂接口定义的一组产品中的一类产品。
* 当生产的类型具有一定的共性但又具有分组的特性时，可以使用该设计模式，便于新增分组时扩展工厂类。


# 模版方法模式
理解：抽象类定义产品的行为以及固定产品行为的组装，统一对外表象。实现类则仅需继承抽象类，实现好产品的行为即可。

分析/推导：

* 抽象类定义好一类产品的行为，实现类继承抽象类并实现具体产品的行为。
* 抽象类定义好这一类产品的对外表象，通过组装该类产品的行为，定义行为的执行顺序来实现。
* 直白点说就是公共方法抽出来到父类中，定义产品的表象就是公共方法。
* 很多三方包提供的扩展方式就使用了该接口，你仅需要继承原实现类并覆盖某个protected方法，然后调用接口类型的execute方法即可。

# 建造者模式
理解：

* 该设计模式和```模版方法模式```很像，但是当产品的表象的生产顺序不固定时，则无法简单的将它放到父类中。
* 该设计模式保留了```模版方法模式```中的使用抽象来定义产品的行为，实现类来实现具体行为的方式。
* 该设计模式新增了构造者定义，用来具体处理产品模块的组装顺序。
* 该设计模式新增了director，用来直接依赖构造者生产产品并交付。

分析/推导：

* 关于产品行为的定义这块和```模版方法模式```很像，就不再赘述了。
* 由于产品的表象不再是静态不变的，而是动态的，同一件产品可能有不同的表象，这时候定义出来一个构造者（builder），用来实际组装产品的行为执行顺序，产生不用的表象。
* 关于director，我的理解他是```设计原则--迪米特法则```的产物。
* ```设计原则--迪米特法则```规定需要最小依赖，即上层不应该直接builder，因为builder不应该是上层的朋友类，即上层不应该了解产品到底有多少生产线，因为builder种类可能很多，上层不需要了解产品和builder间的映射关系，而是仅需要知道他需要生产哪一类产品。
* director就是产品和生产线builder之间的桥梁，director中封装着产品和builder间的对应关系。
* 这样做的好处就是产品的构造对上层来说是原子性的，是透明的，上层完全不需要知道里面的具体逻辑。
