---
layout: post
title:  "go定时器"
date:   2019-11-26
excerpt: "定时器解读"
feature: https://static.justice-love.com/image/jpg/bjfj1.jpg
tag:
- go
- timer
comments: true
---

## 定义

``` go
func Every(t time.Duration, f func()) *time.Ticker {
	ticker := time.NewTicker(t)

	go func() {
		for {
			select {
			case <-ticker.C:
				f()
			}
		}
	}()

	return ticker
}

```
上述代码为go计时器的基础定义方式，略了解go则可以看出，通过从chan（ticker.C）中获取数据来触发func的调用来触发定时器，所以，关键问题是何时向chan中写入数据。

## 解析

先来看看Ticker的定义
``` go
func NewTicker(d Duration) *Ticker {
	if d <= 0 {
		panic(errors.New("non-positive interval for NewTicker"))
	}
	// Give the channel a 1-element time buffer.
	// If the client falls behind while reading, we drop ticks
	// on the floor until the client catches up.
	c := make(chan Time, 1)
	t := &Ticker{
		C: c,
		r: runtimeTimer{
			when:   when(d),
			period: int64(d),
			f:      sendTime,
			arg:    c,
		},
	}
	startTimer(&t.r)
	return t
}

type Ticker struct {
	C <-chan Time // The channel on which the ticks are delivered.
	r runtimeTimer
}

```
