---
layout: post
title:  "设计模式（三）"
date:   2017-01-30
excerpt: "设计原则：责任链模式，装饰模式，策略模式"
tag:
- 设计模式
- 责任链模式
- 装饰模式
- 策略模式
comments: true
---
> 今天是设计模式连载的第二篇，记录了责任链模式，装饰模式，策略模式。同样每个设计模式的详解都包括的我的理解以及我的分析推导过程。

# 责任链模式
理解：

* 该设计模式可以用来封装上层模块对底层逻辑的感知，将底层的执行逻辑封装成链式结构，上层模块不再需要知道具体的一个业务场景应该由哪一个底层模块来处理。
* 类似```模板方法模式```，抽象类中定义好公共的链条节点的执行逻辑（抽象方法）和传递逻辑，而具体的底层实现类则只需实现执行逻辑（抽象方法）即可。

分析／推导：

* 如果不用该设计模式，上层调用者则需要知道各个业务场景应该调用对应的哪一个底层模块。
* 使用该设计模式，则可以做到具体的调用模块对上层透明，通用的调用和传递逻辑在抽象方法里定义即可。
* 缺点，调用链路可能会比较复杂，不适合问题的追踪定位。


# 装饰模式
理解：
* 为了解决业务扩展时无限增加子类的问题，使用装饰类，类似代理类的特性，来扩展原有的方法。
* 装饰模式相对于继承增加子类的方式，可以做到动态装饰，只需要动态增加外层的包装类即可（想想ByteInputStream, BufferedInputStream 等）。

分析／推导：

* 该设计模式是当需要在底层模块上进行扩展，考虑到如果简单继承的话方法覆盖重写的话，底层模块会很臃肿，不易维护。
* 对底层模块增加一层代理，即装饰接口，同样继承底层模块接口，装饰类则仅需完成一些扩展的工作，核心仍然是调用底层模块，并且返回类型仍然是底层模块接口类型。
* 装饰类返回的类型仍然是底层模块类型，装饰类所做的工作对上层来说透明，上层仍然是按照底层模块接口类型的使用方式来使用装饰类。
* 装饰类可以动态嵌套，一般是需要你在new的时候将__代理／修饰__的核心对象传递过来即可，配合上上一条，即传递的核心对象即可以是底层模块，也可以是已经被装饰类封装之后的代理类。

# 策略模式
理解：
* 